<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns#">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="the blog of Tudor Roman">
	<meta name="author" content="Tudor Roman">
	<meta name="keywords" content="tudor roman, tudor's blog, blog, linux, unix">
	<meta name="theme-color" content="#333">

	<meta property="og:title" content="How to learn Computer Programming">
	<meta property="og:type" content="article">
	<meta property="og:description" content="the blog of Tudor Roman">
	<meta property="og:author" content="Tudor Roman">
	<meta property="og:site_name" content="tudor's blog">

	<!-- jekyll-feed gem required -->
	<link type="application/atom+xml" rel="alternate" href="/feed.xml" title="tudor's blog" />

	<link rel="stylesheet" href="/blog/css/main.css">
	<link rel="icon" href="/blog/favicon.png">
	<title>How to learn Computer Programming - tudor's blog</title>
</head>
<body>
	<main>
		<header class="site-header">
			<h1 class="site-title"><a href="/blog/">tudor's blog</a></h1>
			<nav class="site-nav">
				
					
				
					
					
						<a href="/blog/about/" class="">About</a>
					
	            	
				
					
					
	            	
				
					
					
	            	
				
					
					
	            	
				
					
					
	            	
				
			</nav>
		</header>
		<article class="post">
    <h2 class="post-header">How to learn Computer Programming</h2>
    <p class="post-subtitle">Probably in a better way</p>
    <p class="post-meta">2017-10-27 19:03:47+03:00</p>
    <p>Computer programming is one of the things that make you feel like a creator, you
create algorithms that imply data structures, relationships, interaction,
basically anything that involves data, an abstract construct that carries
information. Being a computer programmer makes you the master of your data. It
lets you take a break from our conflict-filled, merciless world in favor of the
logical, perfect, digital realm. Programming implies creativity, ambition,
curiosity, and most importantly, fun, empowering your freedom of doing amazing
things.</p>

<p>But how does one become the master of their own logical world?</p>

<p>I am going to share my on-going experience and some observations that I made
along the way.</p>

<h3 id="some-background">Some background</h3>

<p>I have always been fascinated by computers, big boxes filled with electronics
that eat electricity and produce data. When I was a young(er) boy I was carelessly
fiddling around with the control panel in Windows XP, trying to uncover every
function of the operating system, and then reading more about them on the
internet. It was <em>clearly</em> some kind of magic, and I wanted to master it.</p>

<p>I decided to study hard and go to a computer science-oriented high school, that
also had middle school classes, in fifth grade. There, I joined the CS computer
club hosted by <a href="http://cristian.francu.com">Cristian Frâncu</a> where I started
learning serious stuff basically from scratch.</p>

<h3 id="beginning-programming">Beginning programming</h3>

<p>The basis of programming is <a href="https://en.wikipedia.org/wiki/Computational_thinking">computational thinking</a>. To think “computationally”, you must develop your abstract thinking (the <em>abstraction</em> component of computational thinking) to be able to create <em>algorithms</em>, an ordered sequence of rules that the computer executes. Programming implies elaborating an algorithm and implementing it for the machine.</p>

<p>In fifth grade, we first learned basic algorithms and represented them with flowcharts. One
example is an algorithm that determines whether an integer is a palindrome or
not.</p>

<p><img src="https://i.imgur.com/69LSgr9.png" alt="palindrome flowchart" /></p>

<p><em>Credit: Cristian Frâncu. Licensed under GNU FDL</em></p>

<p>Instead of beginning programming with some simple programming
language like Python, we were beginning with algorithms. And that’s the moment I
realized that’s the right thing to do.</p>

<p>Another important thing that everyone should learn when starting learning how to
program is <a href="https://en.wikipedia.org/wiki/Structured_programming">structured programming</a>. I can’t emphasis this enough, it <strong>is</strong> a game-changer. Basically don’t use <code class="highlighter-rouge">goto</code> or <code class="highlighter-rouge">break</code> instructions unless absolutely necessary.</p>

<p>For example, let’s write a simple array search. We’re trying to find an element
<code class="highlighter-rouge">e</code> in the array <code class="highlighter-rouge">arr</code>.</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">e</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"found x</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>At a first glance, it does what it should: it prints “found x” if <code class="highlighter-rouge">x</code> is a
member of <code class="highlighter-rouge">arr</code>. But the algorithm itself sounds broken.</p>

<p>The algorithm should be the following:</p>

<ol>
  <li>Take each element of <code class="highlighter-rouge">arr</code></li>
  <li>If the element equals <code class="highlighter-rouge">e</code>, print “found x”</li>
</ol>

<p>What the code above actually does:</p>

<ol>
  <li>Take each element of <code class="highlighter-rouge">arr</code></li>
  <li>If the element equals <code class="highlighter-rouge">e</code>, print “found x”</li>
  <li>Abort the search.</li>
</ol>

<p>A better, structured programming code is the following:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">e</span><span class="p">)</span>
    <span class="n">i</span><span class="o">++</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"found x</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
</code></pre>
</div>

<h3 id="moving-on-with-actual-programming">Moving on with actual programming</h3>

<p>After “mastering” flowcharts, it was time to learn a real programming language.
And we (at the CS club), as fresh programming learners, started with C.</p>

<p>And let me tell you why C is the best programming language for beginners. Not
Python, not Ruby, not Scratch (god forbid), but C.</p>

<p>C is very simple, and pretty close to the metal. Not as close to the metal as
assembly, yet still not as high-level as Python. It is the perfect middle ground
for programming learners, because it forces you to write efficient, from-scratch
code. And it has a pretty strict type system.</p>

<p>In C you have to define the data type for each and every variable and array you
use. There is no such thing as iterators, you have to keep an index and iterate
manually through the array. It doesn’t have any kinds of shortcuts, which is
good for first-time programmers.</p>

<p>You’re constantly reminded that computer
programming is serious stuff and you must treat it like so. You can’t leave
unused variables scattered in the code or forget to indent your code. You’re
making an ass out of yourself. Ignorance is the worst thing that destroys the
world, let alone programming. If you don’t have a high enough degree self respect, or a high enough degree of respect for programming, then you’re wasting your time. Either exercise your self respect, or just give up on programming, it’s a waste of time if you lack the necessary dedication.</p>

<p>We exercised programming by solving computer science problems on sites like
<a href="http://codeforces.com">codeforces</a>, <a href="https://csacademy.com">csacademy</a>,
<a href="http://acm.timus.ru">timus</a> and <a href="http://varena.ro/">varena</a> (varena is available only in
Romanian). These problems are short tasks that have very tight memory and time constraints, forcing
the solver to think each data structure, algorithm and variable declaration
carefully. <a href="http://codeforces.com/contest/580/problem/B">Example problem</a>.</p>

<p>Over the years I learned many algorithms, like <a href="https://en.wikipedia.org/wiki/Selection_sort">select sort</a>, <a href="https://en.wikipedia.org/wiki/Quicksort">quicksort</a>, <a href="https://en.wikipedia.org/wiki/Breadth-first_search">breadth-first search</a> and many more. There are many online resources for learning these, such as <a href="https://apps.topcoder.com/forums/?module=Main">The Topcoder Forum</a>.</p>

<p>Further reading: <a href="http://algopedia.ro/wiki/index.php/Introduction_to_Algorithms">Introduction to Algorithms</a> by Cristian Frâncu, <a href="https://web.stanford.edu/class/cs101/">CS101 - Introduction to Computing Principles</a> by Stanford University.</p>

<p>Also, make sure to participate in online CS contests held by Codeforces and
CSAcademy!</p>

<h3 id="drifting-to-real-world-programming">Drifting to real-world programming</h3>

<p>The main difference between competitive programming (solving problems) and
real-word programming is that you have much more constraints than time and
memory and that usually you don’t make only the solution, you also make the
problem, and you generally have more freedom in the whole project. It’s a whole
new world.</p>

<p>To get started, you need to make <em>projects</em>, <strong>lots</strong> of them, like a simple
snake clone with text-based graphics, or a text-based adventure, a web
application, anything!</p>

<p>This is the step that requires the most <em>dedication</em>. It is one of the hardest
steps in the process of learning computer programming.</p>

<h3 id="trying-new-things">Trying new things</h3>

<p>Diversity, in good measure, is very good for you in general, not just for
programming. Experiment with new programming languages, learn how to make
web apps, fiddle with micro-controllers like the <a href="https://www.arduino.cc/en/Guide/Introduction">Arduino</a>.</p>

<p>I first started by reading <a href="http://www.headfirstlabs.com/books/hfjava/">Head First Java</a>,
that’s when I learned about object-oriented programming, the first real programming 
paradigm that I’ve learned. It was mind blowing, so structured, so hierarchical, it 
has changed my way of thinking. Although the Java programming language is well-known
as an ugly language and platform, the underlying concepts are very useful for a
programmer.</p>

<p>In one summer vacation I tried to make a video game using the amazing <a href="https://libgdx.badlogicgames.com/">LibGDX</a> game development library. I discovered eventually that game dev is not for me, mostly because it implies making art assets. Still, the math involved with it is very useful.</p>

<p>And Java’s ugliness convinced me to learn Ruby and eventually Ruby on Rails.
My dad gave me this neat idea to make a simple online educational platform
where students can read lessons and submit homework. Each student was assigned
a class, and each class had a set of lessons. It was for my mom, she is a
teacher. And I started writing that thing using Ruby on Rails. My knowledge of
Rails was null at the moment, I learned it as I progressed.</p>

<p>And I learned about the <a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">Model-view-controller</a> pattern, <a href="https://en.wikipedia.org/wiki/SQL">SQL</a>
databases, templates (for the views), <a href="https://en.wikipedia.org/wiki/HTML">HTML</a>, <a href="https://en.wikipedia.org/wiki/Cascading_Style_Sheets">CSS</a> etcetera. One
important observation I’ve made is that all those components that make up a
system must be separated. You can’t just mix up the views with the controllers.
They are all separate things that interact with each other. Breaking up big
components into smaller components is very important when working with
computers.</p>

<p>The point is, never stop exploring. Curiosity is a very important trait for
anyone who wants to excel in the field.</p>

<h3 id="communities">Communities</h3>

<p>It’s always a good idea to find people who are interested in the same things as
you. You can share opinions, help each others and <em>learn</em>. When talking about
computer programming, the biggest communities can always be found on the web.</p>

<p>The ground-breaking moment as a young programmer was when I discovered one of
the biggest online community of people: <a href="https://reddit.com/">Reddit</a> and a
couple of subreddits that I found to be interesting: <a href="https://redit.com/r/programming">/r/programming</a>,
<a href="https://reddit.com/r/learnprogramming">/r/learnprogramming</a> (very useful resource), <a href="https://reddit.com/r/linux">/r/linux</a>,
<a href="https://reddit.com/r/polandball">/r/polandball</a>, <a href="https://reddit.com/r/listentothis">/r/listentothis</a> and many others.</p>

<p>However, it is always better to always have friends around you, whom you can
talk face-to-face about programming. Being in a CS-oriented school for 4 years
certainly helped me find such people, although many of them continued with
competitive programming (which is very sad in my opinion). My boy
<a href="https://cip.fun">Ciprian Ionescu</a> is probably my only friend who fully
understands me when I’m talking about programming stuff, and I can’t stress it
enough, you <strong>need</strong> such people in your life.</p>

<h3 id="unix-and-ricing">Unix and ricing</h3>

<p>I had this neat idea of installing Linux in dual-boot on my laptop. And the
first Linux distro that I installed on my laptop was <a href="https://archlinux.org/">Arch
Linux</a> because the best way to learn something (in
this case Linux) for me is <a href="http://blog.z3bra.org/2013/08/the-hard-way.html">the hard way</a>, as described by master <a href="http://z3bra.org">z3bra</a>. Make sure to read the article, it’s very good.</p>

<p>So I downloaded the ISO, booted it up, and followed the <a href="https://wiki.archlinux.org/index.php/installation_guide">installation guide</a>. I went all or nothing. Without prior experience. That was going to be <strong>FUN</strong>. Ten minutes later, it booted. Afterwards I created a user, installed some essentials programs like Firefox and the X server and continued the journey of learning Linux blindfolded.</p>

<p>Now, time for some back-story. Two weeks before I begun my Linux journey I
discovered <a href="https://reddit.com/r/unixporn">/r/unixporn</a> (not NSFW, I promise!).
It’s a subreddit dedicated to desktop customization on Unix-like platforms
(usually Linux). And it was Unix for a reason. Many posts that hit the
frontpage at that time featured tiling <a href="https://wiki.installgentoo.com/index.php/GNU/Linux_ricing#Window_Managers">window managers</a>. Instead of running a
full-fledged <a href="https://wiki.installgentoo.com/index.php/GNU/Linux_ricing#Desktop_Environments">desktop environment</a> like GNOME or KDE, users were using
lightweight programs called “window managers” that have the job of, well,
managing windows: resizing them, listening to their requests (and fulfilling
them), grouping them by workspaces and others. Every window manager has its
bells and whistles, the most popular on unixporn being <a href="https://i3wm.org/">i3</a>. i3 is a
tiling window manager, meaning that instead of just putting windows on the
screen, windows in i3 always take as much space as possible on the screen,
like tiles of different sizes on a wall. It it lightweight, easy to use and
has a simple configuration file syntax.</p>

<p>Back to my Linux experience, instead of installing a familiar desktop
environment to begin with, I just installed i3 and configured it to suit some of
my needs. It all felt spectacular, I was in charge of every aspect of the
operating system I was using.</p>

<p>Afterwards I tried to “rice” my system. It was looking magnificent “back then”
(2015), but now I think that it looks absolutely horrible. <a href="https://i.redd.it/1n8wmuly19kz.png">Here is a recent
screenshot</a>.</p>

<p>And I went down the rabbit hole. This is the time when the dedication and
curiosity traits for programming are being put to good use.</p>

<p>I ended up writing pretty much my own mini desktop environment by gluing
together scripts and little programs. For example I made a status bar script
that uses <a href="https://github.com/lemonboy/bar">lemonbar</a> to display the current time, date, currently
playing song, speaker volume and workspaces. <a href="https://github.com/tudurom/dotfiles/blob/980dc58ad655fbe01d9baf4e2e00957e27399b2c/wm/bin/minbar">This is the script in its current
state</a>.</p>

<p>And that’s the moment I realized how beautiful the <a href="https://en.wikipedia.org/wiki/Unix_philosophy">Unix philosophy</a> is. A decades-old philosophy that say that programs should do one thing and do it well and communicate to each other through the simple channel of text and pipes, encouraging composition. And that’s exactly what I was doing with the bar script. It was pulling information <em>as text</em> from programs like <code class="highlighter-rouge">amixer</code> that provides sound device information, processed it with other small programs like <code class="highlighter-rouge">grep</code> and <code class="highlighter-rouge">sed</code> and finally gave it to <code class="highlighter-rouge">lemonbar</code>.</p>

<p>It was a symphony of programs. Many performers (programs) making up a musical
masterpiece, following the instructions of the music paper, coordinated by the
conductor. Truly beautiful.</p>

<p>Remember when I said something about breaking big pieces of code into smaller
pieces? The Unix philosophy is exactly that, taken to the next level.</p>

<h3 id="the-nixers">The Nixers</h3>

<p>Around the time I was fiddling with scripts on my Linux desktop I discovered a
great community of people who had the same passion for Unix as I did:
<a href="https://nixers.net/">Nixers</a>. And they have an IRC channel for talking stuff
about Unix!</p>

<p>I chipped in, talked to many great people (they should be listed on my
<a href="https://tudorr.xyz/res/">resources page</a>) about Unix, programming, desktop
customization, philosophy… Learning things is always easier with friends!</p>

<p>Two members of nixers, z3bra and <a href="https://lyngvaer.no/">dcat</a> wrote a great
set of small programs names <a href="https://github.com/wmutils/">wmutils</a>. One
program prints the ID of the currently focused window, another one moves a
window… You can figure out that they are only very simple programs with very
simple jobs that can be combined in an infinity of possibilities.</p>

<p>Using these programs I ditched the window manager I was using at that time in
favor of a set of scripts based on wmutils that together made up a simple
window manager. My shell-script based desktop environment was almost fully
script-based. I eventually extended it and added a notification system and
other stuff, inspired by <a href="http://blog.z3bra.org/2014/04/pop-it-up.html">z3bra’s post “Pop it up!”</a>. But the whole hacked around window manager was so simple, it lacked a ton of useful features, like multi-display support. It was limited to only one display.</p>

<p>I wrote a set of small programs in wmutils-esque fashion called
<a href="https://github.com/tudurom/disputils">disputils</a>. I modified some parts of
the shell glue window manager and it eventually had multi-display support.</p>

<p>But what about protocols like <a href="https://en.wikipedia.org/wiki/Extended_Window_Manager_Hints">EWMH</a> that define for example how a window should request to be maximized (for example when you double click the Youtube player)? It was clearly not in the X11 spec, and wmutils had absolutely no support for it.</p>

<p>It was clearly the time for something more complex.</p>

<h3 id="the-big-project">The big project</h3>

<p>I’ve already told you to make a lot of software projects, big and small, to
practice the art of programming.</p>

<p>Eventually you will end up starting you first <strong>big</strong> project. I followed the
hard way and made my very own window manager. I named it
<a href="https://github.com/tudurom/windowchef">windowchef</a>.</p>

<p>These are the steps I followed in order to make something:</p>

<h4 id="know-your-target">Know your target</h4>

<p>So I was going to write a window manager. What should be the goals of the
project? I settled upon these goals:</p>

<ul>
  <li>It should be very simple</li>
  <li>It should be 100% compatible with wmutils and other window manipulation
tools</li>
  <li>It should do one thing and do it well: manage the damn windows</li>
  <li>It should have a limited, but big enough for comfortable usage, feature set,
such as limited EWMH support.</li>
  <li>It should configured and controlled entirely from a “remote-control” program.</li>
  <li>It shouldn’t handle keyboard input at all.</li>
</ul>

<p>The “remote-control” goal has come advantages. The user can configure keyboard
shortcuts for moving the windows by using a program like
<a href="https://github.com/baskerville/sxhkd">shxkd</a> that executes commands for certain
configured shortcuts, while also making it possible for external programs to
interact with the window manager, thus adhering to the Unix philosophy.</p>

<h4 id="start-small">Start small</h4>

<p>After having some goals in mind, I started implementing something simple.
First, I made a program that is barely considered a window manager, letting
the X server to do most of the work. My program could spawn terminal windows
under the mouse pointer and focus the windows under the pointer.
<a href="https://github.com/dcat/swm">swm</a>’s source code by dcat helped me a lot.</p>

<h4 id="moving-on">Moving on</h4>

<p>One window manager that is pretty close in goals to mine is
<a href="https://github.com/venam/2bwm">2bwm</a>. I started studying its source code and
implemented the basic stuff in mine (a window manager requires quite a lot of
boilerplate code). I soon had a working prototype that could draw borders and
move and resize windows with commands from the client. I implemented a very
simple client that can only send commands without receiving answers, inspired by
<a href="https://www.uninformativ.de/blog/postings/2016-01-05/0/POSTING-en.html">this post about vain’s katriawm</a>.</p>

<p>In a couple of weeks windowchef was <a href="https://www.reddit.com/r/unixporn/comments/54m0y0/oc_my_window_manager_is_ready_to_share/">done</a>.</p>

<h3 id="open-source">Open source</h3>

<p>I’m writing this article because I want to help people to learn from my
experiences and eventually I will learn from their experiences. This is why
people have blogs, to share their experiences and findings.</p>

<p>I love the open-source community. It’s one of the best things that has ever
happened to software in general. I always open source all my programs to let
people study and learn from my programs. Sometimes people send patches / pull
requests, it makes me really happy!</p>

<p>I really, really encourage everyone to use and contribute to open-source
projects. You’re helping everyone, especially yourself.</p>

<p>My first real steps into opensource were when I published a silly web app
called <a href="https://github.com/tudurom/albumify">“Albumify”</a>. It lets people make <a href="https://imgur.com">imgur</a>-like picture
albums, entirely client-side. And it looked horrible:</p>

<p><img src="https://pub.tudorr.xyz/blog/how-to-programming/albumify-old.png" alt="The Old Albumify" /></p>

<p>And I advertised this silly project on /r/unixporn…</p>

<p>The next day I woke up with this:</p>

<p><img src="https://pub.tudorr.xyz/blog/how-to-programming/firstpr.png" alt="My first pull request" /></p>

<p>I was stoked!!! Someone actually liked my work and decided to improve it! This
is how the web site looked after some “minor” changes by Dylan:</p>

<p><img src="https://pub.tudorr.xyz/blog/how-to-programming/albumify.png" alt="The new albumify" /></p>

<p>It was entirely different. Of course, to return the favor, I contributed to his
big project, <a href="https://github.com/dylanaraps/neofetch">neofetch</a>. I was his
first contributor!</p>

<p>Now, windowchef actually gained traction. As of today it has 116 stars on
GitHub, it actually has users! It is also included in the software
repositories of <a href="https://voidlinux.eu/">Void Linux</a>. One of the beauties of
opensource is that people can come with <a href="https://github.com/tudurom/windowchef/pulls?q=is%3Apr+is%3Aclosed">all sorts of pull requests</a>. Some of them were pretty big, like <a href="https://github.com/tudurom/windowchef/pull/27">this one</a> that implements cardinal focus. You can tell the WM to focus the first window in a given direction.</p>

<p>So you shouldn’t just opensource your code to make it easier to study, you
should also make it opensource for a confidence boost ;)</p>

<h3 id="real-life-projects">Real-life projects</h3>

<p>When you feel that you’re ready, you should pull the trigger and make that
dream project of yours come to life. I started the <a href="https://github.com/xmc-dev">XMC
Project</a> together with <a href="https://cip.fun">Ciprian</a>.
It will be a very flexible CS problem platform and contest manager kinda like
Codeforces based on microservices. I have already implemented the
authentication and authorization server, based on OAuth2. It feels real. And so
it will be.</p>

<p>Sadly I don’t have any experience in the development industry, I’m
currently in 9th
grade.</p>

<p>So in conclusion, to learn programming:</p>

<ol>
  <li>Be in the correct mindset. Be curious, ambitious, dedicate yourself to the
arts of computer programming.</li>
  <li>Start with the basics: algorithms. Learn C, be close to the algorithms and
the machine.</li>
  <li>Solve harder problems, learn data structures.</li>
  <li>Make your own software projects. Lots of them, anything that comes in 
your mind.</li>
  <li>Learn new technologies, programming languages, design patterns, while
making your own projects.</li>
  <li>Be in charge of your personal machine. Use Linux, customize your desktop
experience.</li>
  <li>Join programming communities. Meet new people. Learn with them! Join online
forums!</li>
  <li>Share your projects, opensource anything. If you made something you’re
truly proud of, post about it on <a href="https://reddit.com/">reddit</a>, <a href="https://news.ycombinator.com/">Hacker
News</a>, forums. Make yourself known. If you
don’t stand out nobody will approach you.</li>
  <li>Be open to criticism and software contributions. Contribute to other
projects, criticise others!</li>
  <li>Always keep learning.</li>
</ol>

<p>Thank you for reading, have a nice day! If you’re interested, you can find all
my software projects on <a href="https://github.com/tudurom">my GitHub</a>.</p>

    
</article>

		<footer>
			<hr />
			<nav class="footer-nav">
				<ul>
					
					<a href="/blog/" id="back_link">Back</a>
					
					<a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width: 0; float: right;" src="/blog/assets/cc.png" /></a>
				</ul>
			</nav>
	    </footer>
	</main>
	
</body>
</html>
